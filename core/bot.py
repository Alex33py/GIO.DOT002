#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GIO Crypto Bot v3.0 Enhanced Modular - Main Bot Class
"""

import pytz
import sys
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime
import asyncio
import time

# –ë–∞–∑–æ–≤—ã–µ –∏–º–ø–æ—Ä—Ç—ã
from config.settings import (
    logger,
    PRODUCTION_MODE,
    DATA_DIR,
    SCENARIOS_DIR,
    DATABASE_PATH,
    TRACKED_SYMBOLS,
    SCANNER_CONFIG,
)
from config.constants import TrendDirectionEnum, Colors

# –ò—Å–∫–ª—é—á–µ–Ω–∏—è
from core.exceptions import (
    BotInitializationError,
    BotRuntimeError,
    APIConnectionError,
)
from utils.validators import DataValidator
from utils.helpers import ensure_directory_exists, current_epoch_ms, safe_float
from utils.performance import async_timed, get_process_executor

# –ö–æ–Ω–Ω–µ–∫—Ç–æ—Ä—ã
from connectors.bybit_connector import EnhancedBybitConnector
from connectors.binance_connector import BinanceConnector
from connectors.binance_orderbook_websocket import BinanceOrderbookWebSocket
from connectors.news_connector import UnifiedNewsConnector

# Core –º–æ–¥—É–ª–∏
from core.memory_manager import AdvancedMemoryManager
from core.scenario_manager import ScenarioManager
from core.scenario_matcher import UnifiedScenarioMatcher
from core.veto_system import EnhancedVetoSystem
from core.alerts import AlertSystem
from core.decision_matrix import DecisionMatrix
from core.triggers import TriggerSystem
from core.simple_alerts import SimpleAlertsSystem
from alerts.enhanced_alerts_system import EnhancedAlertsSystem

# Trading
from trading.signal_generator import AdvancedSignalGenerator
from trading.risk_calculator import DynamicRiskCalculator
from trading.signal_recorder import SignalRecorder
from trading.position_tracker import PositionTracker

# from trading.roi_tracker import ROITracker as AutoROITracker
from trading.unified_auto_scanner import UnifiedAutoScanner

# Analytics
from analytics.mtf_analyzer import MultiTimeframeAnalyzer
from analytics.volume_profile import EnhancedVolumeProfileCalculator
from analytics.enhanced_sentiment_analyzer import UnifiedSentimentAnalyzer
from analytics.cluster_detector import ClusterDetector

# Filters
from filters.multi_tf_filter import MultiTimeframeFilter
from filters.confirm_filter import ConfirmFilter


# Telegram
from telegram_bot.telegram_handler import TelegramBotHandler
from telegram_bot.roi_tracker import ROITracker as TelegramROITracker
from telegram_bot.patches import apply_analyze_batching_all_patch

# Scheduler
from apscheduler.schedulers.asyncio import AsyncIOScheduler


class GIOCryptoBot:
    """GIO Crypto Bot - –ì–ª–∞–≤–Ω—ã–π –∫–ª–∞—Å—Å —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞"""

    def __init__(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞"""
        import time

        self.start_time = time.time()
        logger.info(
            f"{Colors.HEADER}üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è GIOCryptoBot v3.0...{Colors.ENDC}"
        )

        # –§–ª–∞–≥–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        self.is_running = False
        self.initialization_complete = False
        self.shutdown_event = asyncio.Event()

        # –î–∞–Ω–Ω—ã–µ
        self.market_data = {}
        self.news_cache = []
        self._last_log_time = 0

        # –ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
        self.memory_manager = None
        self.bybit_connector = None
        self.binance_connector = None
        self.okx_connector = None
        self.coinbase_connector = None
        self.news_connector = None
        self.orderbook_ws = None
        self.scenario_manager = None
        self.scenario_matcher = None
        self.veto_system = None
        self.alert_system = None
        self.decision_matrix = None
        self.trigger_system = None
        self.mtf_analyzer = None
        self.volume_calculator = None
        self.signal_generator = None
        self.risk_calculator = None
        self.signal_recorder = None
        self.position_tracker = None
        self.roi_tracker = None
        self.telegram_bot = None
        self.scheduler = None

        # –û–±—ä–µ–¥–∏–Ω—ë–Ω–Ω—ã–µ –º–æ–¥—É–ª–∏
        self.auto_scanner = None
        self.auto_roi_tracker = None
        self.simple_alerts = None
        self.enhanced_sentiment = None
        self.ml_sentiment = None
        self.enhanced_alerts = None
        self.cluster_detector = None

        logger.info("‚úÖ –ë–∞–∑–æ–≤–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞")

        # –ú–∏–≥—Ä–∞—Ü–∏—è –ë–î
        self._migrate_database()

    def _migrate_database(self):
        """–ú–∏–≥—Ä–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
        try:
            import sqlite3
            import os

            db_path = os.path.join(DATA_DIR, "gio_bot.db")

            if not os.path.exists(db_path):
                logger.warning("‚ö†Ô∏è –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –µ—â—ë –Ω–µ —Å–æ–∑–¥–∞–Ω–∞")
                return

            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()

            cursor.execute("PRAGMA table_info(signals)")
            columns = [row[1] for row in cursor.fetchall()]

            if "updated_at" not in columns:
                logger.info("üìä –ú–∏–≥—Ä–∞—Ü–∏—è –ë–î: –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ–ª–æ–Ω–∫–∏ updated_at...")
                cursor.execute(
                    """
                    ALTER TABLE signals
                    ADD COLUMN updated_at TEXT DEFAULT NULL
                """
                )
                conn.commit()
                logger.info("‚úÖ –ö–æ–ª–æ–Ω–∫–∞ updated_at –¥–æ–±–∞–≤–ª–µ–Ω–∞!")

            cursor.execute("SELECT COUNT(*) FROM signals WHERE updated_at IS NULL")
            null_count = cursor.fetchone()[0]

            if null_count > 0:
                logger.info(f"üìä –ù–∞–π–¥–µ–Ω–æ {null_count} —Å–∏–≥–Ω–∞–ª–æ–≤ —Å updated_at = NULL")
                cursor.execute(
                    """
                    UPDATE signals
                    SET updated_at = datetime('now')
                    WHERE updated_at IS NULL
                """
                )
                conn.commit()
                logger.info(f"‚úÖ –û–±–Ω–æ–≤–ª–µ–Ω–æ {cursor.rowcount} —Å–∏–≥–Ω–∞–ª–æ–≤!")

            conn.close()

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –º–∏–≥—Ä–∞—Ü–∏–∏ –ë–î: {e}", exc_info=True)

    async def initialize(self):
        """–ü–æ–ª–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤"""
        try:
            logger.info(
                f"{Colors.OKBLUE}üîß –ù–∞—á–∞–ª–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤...{Colors.ENDC}"
            )

            # 1. Memory Manager
            logger.info("1Ô∏è‚É£ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Memory Manager...")
            self.memory_manager = AdvancedMemoryManager(max_memory_mb=1024)

            # 1Ô∏è‚É£.5 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è LogBatcher
            logger.info("1Ô∏è‚É£.5 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è LogBatcher...")
            from utils.log_batcher import log_batcher

            self.log_batcher = log_batcher
            await self.log_batcher.start()
            logger.info("   ‚úÖ LogBatcher –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω (—Å–≤–æ–¥–∫–∏ –∫–∞–∂–¥—ã–µ 30s)")

            # 2. –ö–æ–Ω–Ω–µ–∫—Ç–æ—Ä—ã
            logger.info("2Ô∏è‚É£ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–æ–≤...")

            # Bybit
            self.bybit_connector = EnhancedBybitConnector()
            await self.bybit_connector.initialize()
            logger.info("   ‚úÖ Bybit connector initialized")

            # 2Ô∏è‚É£.2 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Binance Orderbook WebSocket
            logger.info("2Ô∏è‚É£.2 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Binance Orderbook WebSocket...")
            self.binance_orderbook_ws = BinanceOrderbookWebSocket(
                symbols=TRACKED_SYMBOLS,  # ["BTCUSDT", "XRPUSDT"]
                depth=20,  # 20 —É—Ä–æ–≤–Ω–µ–π orderbook
            )
            logger.info("   ‚úÖ Binance Orderbook WebSocket –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

            # ‚≠ê Binance (REST + WebSocket)
            binance_symbols = ["btcusdt", "ethusdt", "solusdt"]

            self.binance_connector = BinanceConnector(
                symbols=binance_symbols, enable_websocket=True
            )

            # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å callbacks
            self.binance_connector.set_callbacks(
                {
                    "on_orderbook_update": self.handle_binance_orderbook,
                    "on_trade": self.handle_binance_trade,
                    "on_kline": self.handle_binance_kline,
                }
            )

            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è REST API
            if await self.binance_connector.initialize():
                logger.info("   ‚úÖ Binance connector initialized (REST + WebSocket)")
            else:
                logger.warning("   ‚ö†Ô∏è Binance initialization failed")

            # News
            self.news_connector = UnifiedNewsConnector()

            # ‚≠ê 2.3 OKX (REST + WebSocket) - –í–°–¢–ê–í–ò–¢–¨ –ó–î–ï–°–¨!
            logger.info("2Ô∏è‚É£.3 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è OKX Connector...")
            from connectors.okx_connector import OKXConnector

            okx_symbols = ["BTC-USDT", "ETH-USDT", "SOL-USDT"]

            self.okx_connector = OKXConnector(
                api_key=None,  # Public data only
                api_secret=None,
                passphrase=None,
                symbols=okx_symbols,
                enable_websocket=True,
                demo_mode=False,
            )

            # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å callbacks
            self.okx_connector.set_callbacks(
                {
                    "on_orderbook_update": self.handle_okx_orderbook,
                    "on_trade": self.handle_okx_trade,
                }
            )

            if await self.okx_connector.initialize():
                logger.info("   ‚úÖ OKX connector initialized (REST + WebSocket)")
            else:
                logger.warning("   ‚ö†Ô∏è OKX initialization failed")

            # ‚≠ê 2.4 Coinbase (REST + WebSocket) - –í–°–¢–ê–í–ò–¢–¨ –°–Æ–î–ê!
            logger.info("2Ô∏è‚É£.4 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Coinbase Connector...")
            from connectors.coinbase_connector import CoinbaseConnector

            coinbase_symbols = ["BTC-USD", "ETH-USD", "SOL-USD"]

            self.coinbase_connector = CoinbaseConnector(
                api_key=None,  # Public data only
                api_secret=None,
                symbols=coinbase_symbols,
                enable_websocket=True,
            )

            # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å callbacks
            self.coinbase_connector.set_callbacks(
                {
                    "on_orderbook_update": self.handle_coinbase_orderbook,
                    "on_trade": self.handle_coinbase_trade,
                    "on_ticker": self.handle_coinbase_ticker,
                }
            )

            if await self.coinbase_connector.initialize():
                logger.info("   ‚úÖ Coinbase connector initialized (REST + WebSocket)")
            else:
                logger.warning("   ‚ö†Ô∏è Coinbase initialization failed")

            # 2.5. WebSocket Orderbook –¥–ª—è Bybit L2 –¥–∞–Ω–Ω—ã—Ö
            logger.info("2Ô∏è‚É£.5 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Bybit WebSocket Orderbook...")
            from connectors.bybit_orderbook_ws import BybitOrderbookWebSocket

            self.orderbook_ws = BybitOrderbookWebSocket("BTCUSDT", depth=200)

            async def process_orderbook(orderbook):
                """–û–±—Ä–∞–±–æ—Ç–∫–∞ L2 —Å—Ç–∞–∫–∞–Ω–∞ –∑–∞—è–≤–æ–∫"""
                try:
                    current_time = time.time()
                    bids = orderbook.get("bids", [])[:50]
                    asks = orderbook.get("asks", [])[:50]

                    if not bids or not asks:
                        return

                    bid_volume = sum(float(q) for p, q in bids if q)
                    ask_volume = sum(float(q) for p, q in asks if q)
                    total_volume = bid_volume + ask_volume

                    if total_volume > 0:
                        imbalance = (bid_volume - ask_volume) / total_volume

                        if "BTCUSDT" not in self.market_data:
                            self.market_data["BTCUSDT"] = {}

                        self.market_data["BTCUSDT"]["orderbook_imbalance"] = imbalance
                        self.market_data["BTCUSDT"]["bid_volume"] = bid_volume
                        self.market_data["BTCUSDT"]["ask_volume"] = ask_volume
                        self.market_data["BTCUSDT"]["orderbook_full"] = {
                            "bids": orderbook.get("bids", [])[:200],
                            "asks": orderbook.get("asks", [])[:200],
                            "timestamp": current_time,
                            "depth": 200,
                        }

                        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∏—Å–±–∞–ª–∞–Ω—Å –¥–ª—è Cluster Detector
                        if hasattr(self, "l2_imbalances"):
                            if "BTCUSDT" not in self.l2_imbalances:
                                self.l2_imbalances["BTCUSDT"] = []

                            self.l2_imbalances["BTCUSDT"].append(
                                {
                                    "imbalance": imbalance,
                                    "timestamp": datetime.now(),
                                    "direction": "BUY" if imbalance > 0 else "SELL",
                                }
                            )

                            # –•—Ä–∞–Ω–∏–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 100 –¥–∏—Å–±–∞–ª–∞–Ω—Å–æ–≤
                            if len(self.l2_imbalances["BTCUSDT"]) > 100:
                                self.l2_imbalances["BTCUSDT"] = self.l2_imbalances[
                                    "BTCUSDT"
                                ][-100:]

                        if (
                            abs(imbalance) > 0.75
                            and (current_time - self._last_log_time) > 30
                        ):
                            direction = (
                                "üìà BUY pressure"
                                if imbalance > 0
                                else "üìâ SELL pressure"
                            )
                            logger.info(
                                f"üìä L2 –¥–∏—Å–±–∞–ª–∞–Ω—Å BTCUSDT: {imbalance:.2%} {direction}"
                            )
                            self._last_log_time = current_time

                except Exception as e:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ orderbook: {e}")

            self.orderbook_ws.add_callback(process_orderbook)
            await self.orderbook_ws.start()
            logger.info("   ‚úÖ Bybit WebSocket Orderbook –∑–∞–ø—É—â–µ–Ω (depth=200)")

            # 3. –°—Ü–µ–Ω–∞—Ä–∏–∏ –∏ VETO
            logger.info("3Ô∏è‚É£ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤ –∏ VETO...")
            self.scenario_manager = ScenarioManager(db_path=DATABASE_PATH)

            try:
                scenarios_loaded = await self.scenario_manager.load_scenarios_from_json(
                    filename="gio_scenarios_100_with_features_v3.json"
                )
                if scenarios_loaded:
                    logger.info(
                        f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(self.scenario_manager.scenarios)} —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤"
                    )
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤: {e}")

            self.veto_system = EnhancedVetoSystem()

            # 4. –ê–Ω–∞–ª–∏—Ç–∏–∫–∞
            logger.info("4Ô∏è‚É£ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏...")
            self.mtf_analyzer = MultiTimeframeAnalyzer(self.bybit_connector)
            self.volume_calculator = EnhancedVolumeProfileCalculator()

            logger.info("üîç DEBUG: –ü–æ–ø—ã—Ç–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ ClusterDetector...")

            # Cluster Detector
            try:
                from analytics.cluster_detector import ClusterDetector

                logger.info("üîç DEBUG: ClusterDetector –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω —É—Å–ø–µ—à–Ω–æ")

                logger.info("üîç DEBUG: –°–æ–∑–¥–∞–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ ClusterDetector...")
                self.cluster_detector = ClusterDetector(self)
                logger.info("üîç DEBUG: –≠–∫–∑–µ–º–ø–ª—è—Ä ClusterDetector —Å–æ–∑–¥–∞–Ω")

                logger.info("   ‚úÖ Cluster Detector –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

                # –î–∞–Ω–Ω—ã–µ –¥–ª—è Cluster Detector
                self.l2_imbalances = {}
                self.large_trades = {}
                logger.info("üîç DEBUG: –î–∞–Ω–Ω—ã–µ –¥–ª—è Cluster Detector —Å–æ–∑–¥–∞–Ω—ã")

            except Exception as e:
                logger.error(f"   ‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Cluster Detector: {e}")
                logger.error(f"   ‚ùå Traceback: ", exc_info=True)
                self.cluster_detector = None

            logger.info("üîç DEBUG: –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Cluster Detector")

            # 5. –°–∏—Å—Ç–µ–º—ã –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏–π
            logger.info("5Ô∏è‚É£ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏–π...")
            self.alert_system = AlertSystem()
            self.decision_matrix = DecisionMatrix()
            self.trigger_system = TriggerSystem()

            # 6. –û–±—ä–µ–¥–∏–Ω—ë–Ω–Ω—ã–µ –º–æ–¥—É–ª–∏
            logger.info("6Ô∏è‚É£ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –û–ë–™–ï–î–ò–ù–Å–ù–ù–´–• –º–æ–¥—É–ª–µ–π...")
            self.scenario_matcher = UnifiedScenarioMatcher()
            self.scenario_matcher.scenarios = self.scenario_manager.scenarios
            self.enhanced_sentiment = UnifiedSentimentAnalyzer()

            # ‚≠ê ML Sentiment Analyzer
            logger.info("6Ô∏è‚É£.2 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ML Sentiment Analyzer...")
            from analytics.ml_sentiment_analyzer import MLSentimentAnalyzer

            self.ml_sentiment = MLSentimentAnalyzer(use_gpu=False)
            ml_initialized = await self.ml_sentiment.initialize()

            if ml_initialized:
                logger.info(
                    "   ‚úÖ ML Sentiment Analyzer –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω (FinBERT + CryptoBERT)"
                )
            else:
                logger.warning("   ‚ö†Ô∏è ML models –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã, –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback")

            # 6Ô∏è‚É£.3 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Cross-Exchange Validator
            logger.info("6Ô∏è‚É£.3 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Cross-Exchange Validator...")
            from analytics.cross_exchange_validator import CrossExchangeValidator

            self.cross_validator = CrossExchangeValidator(
                price_deviation_threshold=0.001,  # 0.1%
                volume_spike_threshold=3.0,
                min_exchanges_required=2,
            )
            logger.info("   ‚úÖ Cross-Exchange Validator –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

            # 7. –¢–æ—Ä–≥–æ–≤–∞—è –ª–æ–≥–∏–∫–∞
            logger.info("7Ô∏è‚É£ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–æ—Ä–≥–æ–≤–æ–π –ª–æ–≥–∏–∫–∏...")
            self.risk_calculator = DynamicRiskCalculator(
                min_rr=1.5,
                default_sl_atr_multiplier=1.5,
                default_tp1_percent=1.5,
                use_trailing_stop=True,
            )
            self.signal_recorder = SignalRecorder(db_path=DATABASE_PATH)
            self.position_tracker = PositionTracker(
                signal_recorder=self.signal_recorder
            )

            self.auto_scanner = UnifiedAutoScanner(
                bot_instance=self,
                scenario_matcher=self.scenario_matcher,
                risk_calculator=self.risk_calculator,
                signal_recorder=self.signal_recorder,
                position_tracker=self.position_tracker,
            )

            logger.info(
                "   ‚ö™ AutoROITracker –æ—Ç–∫–ª—é—á–µ–Ω (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è TelegramROITracker)"
            )
            self.simple_alerts = SimpleAlertsSystem(self)

            # ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –§–ò–õ–¨–¢–†–û–í ==========
            logger.info("6Ô∏è‚É£.5 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ñ–∏–ª—å—Ç—Ä–æ–≤...")

            # –ò–º–ø–æ—Ä—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤ (–µ—Å–ª–∏ –µ—Å—Ç—å)
            try:
                from config.filters_config import (
                    CONFIRM_FILTER_CONFIG,
                    MULTI_TF_FILTER_CONFIG,
                )

                use_config = True
            except ImportError:
                logger.info(
                    "‚ÑπÔ∏è filters_config –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã"
                )
                use_config = False
                CONFIRM_FILTER_CONFIG = {
                    "enabled": True,
                    "cvd_threshold": 0.5,
                    "volume_threshold_multiplier": 1.5,
                    "require_candle_confirmation": False,
                    "min_large_trade_value": 10000,
                }
                MULTI_TF_FILTER_CONFIG = {
                    "enabled": True,
                    "require_all_aligned": False,
                    "min_aligned_count": 1,
                    "higher_tf_weight": 2.0,
                }

            # ========== CONFIRM FILTER ==========
            self.confirm_filter = None
            if CONFIRM_FILTER_CONFIG.get("enabled", True):
                try:
                    from filters.confirm_filter import ConfirmFilter

                    self.confirm_filter = ConfirmFilter(
                        bot_instance=self,  # ‚úÖ –ü–µ—Ä–µ–¥–∞–µ–º self
                        cvd_threshold=CONFIRM_FILTER_CONFIG.get("cvd_threshold", 0.2),
                        volume_multiplier=CONFIRM_FILTER_CONFIG.get(
                            "volume_threshold_multiplier", 1.3
                        ),
                        candle_check=CONFIRM_FILTER_CONFIG.get(
                            "require_candle_confirmation", True
                        ),
                        min_large_trade_value=CONFIRM_FILTER_CONFIG.get(
                            "min_large_trade_value", 10000
                        ),
                    )
                    logger.info(
                        f"   ‚úÖ Confirm Filter –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω (CVD‚â•{CONFIRM_FILTER_CONFIG.get('cvd_threshold', 0.5)}%)"
                    )
                except ImportError as e:
                    logger.warning(f"   ‚ö†Ô∏è Confirm Filter –Ω–µ –Ω–∞–π–¥–µ–Ω: {e}")
                    self.confirm_filter = None
                except Exception as e:
                    logger.error(f"   ‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Confirm Filter: {e}")
                    self.confirm_filter = None
            else:
                logger.info("   ‚ÑπÔ∏è Confirm Filter –æ—Ç–∫–ª—é—á—ë–Ω –≤ –∫–æ–Ω—Ñ–∏–≥–µ")

            # ========== MULTI-TIMEFRAME FILTER ==========
            self.multi_tf_filter = None
            if MULTI_TF_FILTER_CONFIG.get("enabled", True):
                try:
                    from filters.multi_tf_filter import MultiTimeframeFilter

                    self.multi_tf_filter = MultiTimeframeFilter(
                        bot=self,
                        require_all_aligned=MULTI_TF_FILTER_CONFIG.get(
                            "require_all_aligned", False
                        ),
                        min_aligned_count=MULTI_TF_FILTER_CONFIG.get(
                            "min_aligned_count", 2
                        ),
                        higher_tf_weight=MULTI_TF_FILTER_CONFIG.get(
                            "higher_tf_weight", 2.0
                        ),
                    )
                    logger.info(
                        f"   ‚úÖ Multi-TF Filter –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω "
                        f"(min_aligned={MULTI_TF_FILTER_CONFIG.get('min_aligned_count', 2)})"
                    )
                # MTF —Ä–∞–±–æ—Ç–∞–µ—Ç —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ —á–µ—Ä–µ–∑ get_mtf_status()

                except ImportError as e:
                    logger.warning(f"   ‚ö†Ô∏è Multi-TF Filter –Ω–µ –Ω–∞–π–¥–µ–Ω: {e}")
                    self.multi_tf_filter = None
                except Exception as e:
                    logger.error(f"   ‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Multi-TF Filter: {e}")
                    self.multi_tf_filter = None
            else:
                logger.info("   ‚ÑπÔ∏è Multi-TF Filter –æ—Ç–∫–ª—é—á—ë–Ω –≤ –∫–æ–Ω—Ñ–∏–≥–µ")

            logger.info("‚úÖ –§–∏–ª—å—Ç—Ä—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã")

            # ========== SIGNAL GENERATOR ==========
            logger.info("7Ô∏è‚É£.5 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Signal Generator...")

            self.signal_generator = AdvancedSignalGenerator(
                bot=self,  # ‚úÖ –î–û–ë–ê–í–õ–ï–ù–û: –ü–µ—Ä–µ–¥–∞–µ–º self
                veto_system=self.veto_system,
                confirm_filter=self.confirm_filter,
                multi_tf_filter=self.multi_tf_filter,
            )

            logger.info("‚úÖ AdvancedSignalGenerator –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

            # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤
            if self.confirm_filter:
                logger.info("   ‚îú‚îÄ Confirm Filter: –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω ‚úÖ")
            else:
                logger.info("   ‚îú‚îÄ Confirm Filter: –æ—Ç–∫–ª—é—á—ë–Ω ‚ö™")

            if self.multi_tf_filter:
                logger.info("   ‚îî‚îÄ Multi-TF Filter: –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω ‚úÖ")
            else:
                logger.info("   ‚îî‚îÄ Multi-TF Filter: –æ—Ç–∫–ª—é—á—ë–Ω ‚ö™")

            # 8. Telegram Bot
            logger.info("8Ô∏è‚É£ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram Bot...")
            self.telegram_handler = TelegramBotHandler(self)
            logger.info("   ‚úÖ Telegram Bot –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

            # 8Ô∏è‚É£.3 –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –ø–∞—Ç—á–∞ /analyze_batching ALL
            logger.info("8Ô∏è‚É£.3 –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –ø–∞—Ç—á–∞ /analyze_batching ALL...")
            apply_analyze_batching_all_patch(self.telegram_handler)
            logger.info("   ‚úÖ –ü–∞—Ç—á –ø—Ä–∏–º–µ–Ω—ë–Ω")

            # 8Ô∏è‚É£.5 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram ROITracker –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π —Å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º —Ü–µ–Ω
            logger.info("8Ô∏è‚É£.5 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram ROITracker...")
            self.telegram_roi_tracker = TelegramROITracker(
                bot=self,  # ‚úÖ –ò–ó–ú–ï–ù–ï–ù–û: bot –≤–º–µ—Å—Ç–æ bot_instance
                telegram_handler=self.telegram_handler,
            )
            logger.info("   ‚úÖ Telegram ROITracker –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —Å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º —Ü–µ–Ω")

            self.roi_tracker = self.telegram_roi_tracker
            logger.info(
                "   ‚úÖ ROI Tracker —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω (TelegramROITracker + price caching)"
            )

            self.enhanced_alerts = EnhancedAlertsSystem(
                bot_instance=self,
            )

            # 8Ô∏è‚É£.6 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Market Dashboard
            logger.info("8Ô∏è‚É£.6 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Market Dashboard...")
            try:
                from telegram_bot.market_dashboard import MarketDashboard
                from telegram_bot.dashboard_commands import DashboardCommands

                # Market Dashboard
                self.market_dashboard = MarketDashboard(self)
                logger.info("   ‚úÖ Market Dashboard –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

                # Dashboard Commands (—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è /market)
                if hasattr(self, "telegram_handler"):
                    # –ü–æ–ª—É—á–∞–µ–º –±–æ—Ç –∏–∑ telegram_handler (–º–æ–∂–µ—Ç –±—ã—Ç—å bot –∏–ª–∏ telegram_bot)
                    telegram_bot_instance = getattr(
                        self.telegram_handler,
                        "bot",
                        getattr(self.telegram_handler, "telegram_bot", None),
                    )

                    if telegram_bot_instance:
                        self.dashboard_commands = DashboardCommands(
                            telegram_bot_instance, self  # AsyncTeleBot instance
                        )
                        logger.info(
                            "   ‚úÖ Dashboard Commands –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã (/market)"
                        )
                    else:
                        logger.warning(
                            "   ‚ö†Ô∏è Telegram bot instance –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ telegram_handler"
                        )
                else:
                    logger.warning(
                        "   ‚ö†Ô∏è telegram_handler –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é /market"
                    )

            except ImportError as e:
                logger.warning(f"   ‚ö†Ô∏è Dashboard –º–æ–¥—É–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã: {e}")
            except Exception as e:
                logger.error(
                    f"   ‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Dashboard: {e}", exc_info=True
                )

            # 9. –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫
            # logger.info("9Ô∏è‚É£ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞...")
            self.setup_scheduler()
            # self.news_connector.update_cache,
            # "interval",
            # minutes=15,
            # id="update_news",
            # name="–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–µ–π",
            # replace_existing=True,
            # )
            logger.info("‚úÖ –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")

            logger.info(
                f"{Colors.OKGREEN}‚úÖ –í—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã (100%)!{Colors.ENDC}"
            )

            self.initialization_complete = True
            logger.info("üöÄ GIOCryptoBot v3.0 –≥–æ—Ç–æ–≤ –∫ –∑–∞–ø—É—Å–∫—É!")

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: {e}", exc_info=True)
            raise BotInitializationError(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –±–æ—Ç–∞: {e}")

    # ‚≠ê –î–û–ë–ê–í–õ–ï–ù–û: Binance WebSocket Callback Handlers

    async def handle_binance_orderbook(self, symbol: str, orderbook: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ Binance orderbook –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π"""
        try:
            ba = self.binance_connector.get_best_bid_ask(symbol)
            if ba:
                spread = self.binance_connector.get_spread(symbol)
                if hasattr(self, "log_batcher"):
                    self.log_batcher.log_orderbook_update("Binance", symbol)

                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ market_data
                if symbol not in self.market_data:
                    self.market_data[symbol] = {}

                self.market_data[symbol]["binance_bid"] = ba[0]
                self.market_data[symbol]["binance_ask"] = ba[1]
                self.market_data[symbol]["binance_spread"] = spread

        except Exception as e:
            logger.error(f"‚ùå Binance orderbook handler error: {e}", exc_info=True)

    async def handle_binance_trade(self, symbol: str, trade: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ Binance real-time trades"""
        try:
            side = "SELL" if trade["is_buyer_maker"] else "BUY"
            value = trade["quantity"] * trade["price"]

            # –õ–æ–≥–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –û–ß–ï–ù–¨ –∫—Ä—É–ø–Ω—ã–µ —Å–¥–µ–ª–∫–∏ > $50k
            if value > 50000:
                logger.info(
                    f"üí∞ Binance {symbol.upper()} Large Trade: "
                    f"{side} {trade['quantity']:.4f} @ ${trade['price']:,.2f} "
                    f"(${value:,.0f})"
                )

                # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ large_trades_cache –¥–ª—è Whale Tracking
                if not hasattr(self, "large_trades_cache"):
                    self.large_trades_cache = {}

                symbol_normalized = symbol.replace("-", "")  # BTC-USDT -> BTCUSDT

                if symbol_normalized not in self.large_trades_cache:
                    self.large_trades_cache[symbol_normalized] = []

                self.large_trades_cache[symbol_normalized].append(
                    {
                        "timestamp": time.time(),
                        "side": side.lower(),  # "buy" –∏–ª–∏ "sell"
                        "volume": value,  # USD value
                        "price": trade["price"],
                        "quantity": trade["quantity"],
                    }
                )

                # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∫–µ—à–∞ (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 100 —Å–¥–µ–ª–æ–∫)
                if len(self.large_trades_cache[symbol_normalized]) > 100:
                    self.large_trades_cache[symbol_normalized] = (
                        self.large_trades_cache[symbol_normalized][-100:]
                    )

        except Exception as e:
            logger.error(f"‚ùå Binance trade handler error: {e}", exc_info=True)

    async def handle_binance_kline(self, symbol: str, kline: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ Binance klines (—Å–≤–µ—á–µ–π)"""
        try:
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –∑–∞–∫—Ä—ã—Ç—ã–µ —Å–≤–µ—á–∏
            if kline["is_closed"]:
                logger.info(
                    f"üïØÔ∏è Binance {symbol.upper()} {kline['interval']} closed: "
                    f"O:{kline['open']:.2f} H:{kline['high']:.2f} "
                    f"L:{kline['low']:.2f} C:{kline['close']:.2f} "
                    f"V:{kline['volume']:.2f}"
                )

        except Exception as e:
            logger.error(f"‚ùå Binance kline handler error: {e}", exc_info=True)

    async def handle_okx_orderbook(self, symbol: str, orderbook: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ OKX orderbook –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π"""
        try:
            ba = self.okx_connector.get_best_bid_ask(symbol)
            if ba:
                spread = self.okx_connector.get_spread(symbol)
                if hasattr(self, "log_batcher"):
                    self.log_batcher.log_orderbook_update("OKX", symbol)

                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ market_data
                symbol_normalized = symbol.replace("-", "")  # BTC-USDT -> BTCUSDT
                if symbol_normalized not in self.market_data:
                    self.market_data[symbol_normalized] = {}

                self.market_data[symbol_normalized]["okx_bid"] = ba[0]
                self.market_data[symbol_normalized]["okx_ask"] = ba[1]
                self.market_data[symbol_normalized]["okx_spread"] = spread

        except Exception as e:
            logger.error(f"‚ùå OKX orderbook handler error: {e}", exc_info=True)

    async def handle_okx_trade(self, symbol: str, trade: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ OKX real-time trades"""
        try:
            value = trade["quantity"] * trade["price"]

            # –õ–æ–≥–∏—Ä—É–µ–º –∫—Ä—É–ø–Ω—ã–µ —Å–¥–µ–ª–∫–∏ > $50k
            if value > 50000:
                logger.info(
                    f"üí∞ OKX {symbol} Large Trade: "
                    f"{trade['side'].upper()} {trade['quantity']:.4f} @ ${trade['price']:,.2f} "
                    f"(${value:,.0f})"
                )
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫—Ä—É–ø–Ω—É—é —Å–¥–µ–ª–∫—É –¥–ª—è Cluster Detector
                if hasattr(self, "large_trades"):
                    symbol_normalized = symbol.replace("-", "")  # BTC-USDT -> BTCUSDT

                    if symbol_normalized not in self.large_trades:
                        self.large_trades[symbol_normalized] = []

                    self.large_trades[symbol_normalized].append(
                        {
                            "price": trade["price"],
                            "quantity": trade["quantity"],
                            "side": trade["side"],
                            "timestamp": datetime.now(),
                        }
                    )

                    # –•—Ä–∞–Ω–∏–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 200 —Å–¥–µ–ª–æ–∫
                    if len(self.large_trades[symbol_normalized]) > 200:
                        self.large_trades[symbol_normalized] = self.large_trades[
                            symbol_normalized
                        ][-200:]

        except Exception as e:
            logger.error(f"‚ùå OKX trade handler error: {e}", exc_info=True)

    async def handle_coinbase_orderbook(self, symbol: str, orderbook: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ Coinbase orderbook –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π"""
        try:
            ba = self.coinbase_connector.get_best_bid_ask(symbol)
            if ba:
                spread = self.coinbase_connector.get_spread(symbol)
                if hasattr(self, "log_batcher"):
                    self.log_batcher.log_orderbook_update("Coinbase", symbol)

                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ market_data
                symbol_normalized = symbol.replace("-", "")  # BTC-USD -> BTCUSD
                if symbol_normalized not in self.market_data:
                    self.market_data[symbol_normalized] = {}

                self.market_data[symbol_normalized]["coinbase_bid"] = ba[0]
                self.market_data[symbol_normalized]["coinbase_ask"] = ba[1]
                self.market_data[symbol_normalized]["coinbase_spread"] = spread

        except Exception as e:
            logger.error(f"‚ùå Coinbase orderbook handler error: {e}", exc_info=True)

    async def handle_coinbase_trade(self, symbol: str, trade: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ Coinbase real-time trades"""
        try:
            value = trade["size"] * trade["price"]

            # –õ–æ–≥–∏—Ä—É–µ–º –∫—Ä—É–ø–Ω—ã–µ —Å–¥–µ–ª–∫–∏ > $50k
            if value > 50000:
                logger.info(
                    f"üí∞ Coinbase {symbol} Large Trade: "
                    f"{trade['side'].upper()} {trade['size']:.4f} @ ${trade['price']:,.2f} "
                    f"(${value:,.0f})"
                )

                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫—Ä—É–ø–Ω—É—é —Å–¥–µ–ª–∫—É –¥–ª—è Cluster Detector
                if hasattr(self, "large_trades"):  # ‚Üê 12 –ü–†–û–ë–ï–õ–û–í!
                    symbol_normalized = symbol.replace("-", "")  # ‚Üê 16 –ü–†–û–ë–ï–õ–û–í!

                    if symbol_normalized not in self.large_trades:  # ‚Üê 16 –ü–†–û–ë–ï–õ–û–í!
                        self.large_trades[symbol_normalized] = []  # ‚Üê 20 –ü–†–û–ë–ï–õ–û–í!

                    self.large_trades[symbol_normalized].append(
                        {  # ‚Üê 16 –ü–†–û–ë–ï–õ–û–í!
                            "price": trade["price"],
                            "quantity": trade["size"],
                            "side": trade["side"],
                            "timestamp": datetime.now(),
                        }
                    )

                    # –•—Ä–∞–Ω–∏–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 200 —Å–¥–µ–ª–æ–∫
                    if len(self.large_trades[symbol_normalized]) > 200:
                        self.large_trades[symbol_normalized] = self.large_trades[
                            symbol_normalized
                        ][-200:]

        except Exception as e:
            logger.error(f"‚ùå Coinbase trade handler error: {e}", exc_info=True)

    async def handle_coinbase_ticker(self, symbol: str, ticker: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ Coinbase ticker updates"""
        try:
            logger.debug(
                f"üìä Coinbase {symbol} Ticker: ${ticker['price']:,.2f} "
                f"24h Vol: ${ticker['volume_24h']:,.0f}"
            )
        except Exception as e:
            logger.error(f"‚ùå Coinbase ticker handler error: {e}", exc_info=True)

    async def get_volume_profile(self, symbol: str) -> Optional[Dict]:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ Volume Profile —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º L2 Orderbook

        Args:
            symbol: –¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞

        Returns:
            Volume Profile –¥–∞–Ω–Ω—ã–µ –∏–ª–∏ None
        """
        try:
            logger.debug(f"üìä –ü–æ–ª—É—á–µ–Ω–∏–µ Volume Profile –¥–ª—è {symbol}...")

            # –î–∞—ë–º WebSocket –≤—Ä–µ–º—è –∑–∞–≥—Ä—É–∑–∏—Ç—å—Å—è (—Ç–æ–ª—å–∫–æ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –≤—ã–∑–æ–≤–µ)
            if not hasattr(self, "_orderbook_ready"):
                logger.debug("‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏ L2 orderbook (3 —Å–µ–∫)...")
                await asyncio.sleep(3)
                self._orderbook_ready = True

            # –ü–†–ò–û–†–ò–¢–ï–¢ 1: Bybit L2 Orderbook (–¥–ª—è BTCUSDT)
            if (
                symbol == "BTCUSDT"
                and self.orderbook_ws
                and hasattr(self.orderbook_ws, "_orderbook")
                and self.orderbook_ws._orderbook
                and len(self.orderbook_ws._orderbook.get("bids", [])) > 0
            ):
                logger.debug("üìä –ò—Å–ø–æ–ª—å–∑—É–µ–º Bybit L2 Orderbook –¥–ª—è Volume Profile")

                volume_profile = await self.volume_calculator.calculate_from_orderbook(
                    self.orderbook_ws._orderbook,
                    price_levels=200,
                )

                if volume_profile:
                    logger.debug(
                        f"   ‚úÖ L2 Orderbook Volume Profile –ø–æ–ª—É—á–µ–Ω (200 levels)"
                    )
                    return volume_profile
                else:
                    logger.warning("   ‚ö†Ô∏è L2 orderbook —Ä–∞—Å—á—ë—Ç –Ω–µ —É–¥–∞–ª—Å—è")

            # –ü–†–ò–û–†–ò–¢–ï–¢ 2: Binance WebSocket Orderbook (–¥–ª—è –¥—Ä—É–≥–∏—Ö —Å–∏–º–≤–æ–ª–æ–≤)
            if self.binance_connector:
                binance_orderbook = self.binance_connector.get_ws_orderbook(
                    symbol.lower(), depth=200
                )

                if (
                    binance_orderbook
                    and binance_orderbook["bids"]
                    and binance_orderbook["asks"]
                ):
                    logger.debug(
                        f"üìä –ò—Å–ø–æ–ª—å–∑—É–µ–º Binance WebSocket Orderbook –¥–ª—è {symbol}"
                    )

                    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —Ñ–æ—Ä–º–∞—Ç –¥–ª—è volume_calculator
                    orderbook_formatted = {
                        "bids": binance_orderbook["bids"],
                        "asks": binance_orderbook["asks"],
                        "timestamp": binance_orderbook.get(
                            "timestamp", datetime.utcnow()
                        ),
                    }

                    volume_profile = (
                        await self.volume_calculator.calculate_from_orderbook(
                            orderbook_formatted,
                            price_levels=200,
                        )
                    )

                    if volume_profile:
                        logger.debug(f"   ‚úÖ Binance Orderbook Volume Profile –ø–æ–ª—É—á–µ–Ω")
                        return volume_profile

            # –ü–†–ò–û–†–ò–¢–ï–¢ 3: Fallback –Ω–∞ aggTrades (REST API)
            logger.debug(f"üìä –ò—Å–ø–æ–ª—å–∑—É–µ–º aggTrades –¥–ª—è {symbol} (fallback)")

            try:
                # –ü—Ä–æ–±—É–µ–º Bybit
                trades = await self.bybit_connector.get_trades(symbol, limit=1000)

                if trades:
                    logger.debug(f"   ‚úÖ –ü–æ–ª—É—á–µ–Ω–æ {len(trades)} trades –∏–∑ Bybit")
                    return {
                        "data_source": "bybit_aggTrades",
                        "trades": trades,
                        "symbol": symbol,
                    }

                # –ï—Å–ª–∏ Bybit –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª, –ø—Ä–æ–±—É–µ–º Binance REST
                if self.binance_connector:
                    binance_trades = await self.binance_connector.get_agg_trades(
                        symbol=symbol.upper(), limit=1000
                    )

                    if binance_trades:
                        logger.debug(
                            f"   ‚úÖ –ü–æ–ª—É—á–µ–Ω–æ {len(binance_trades)} trades –∏–∑ Binance"
                        )
                        return {
                            "data_source": "binance_aggTrades",
                            "trades": binance_trades,
                            "symbol": symbol,
                        }

                logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å trades –¥–ª—è {symbol}")
                return None

            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è trades: {e}")
                return None

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è Volume Profile: {e}")
            import traceback

            logger.error(traceback.format_exc())
            return None

    async def analyze_symbol_with_batching(self, symbol: str) -> Dict:
        """
        Wrapper –¥–ª—è UnifiedAutoScanner —Å MTF Alignment

        –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç –∞–Ω–∞–ª–∏–∑ –Ω–∞ UnifiedAutoScanner –¥–ª—è –ø–æ–ª–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏:
        - MTF Alignment
        - –°—Ü–µ–Ω–∞—Ä–∏–∏
        - Volume Profile
        - News Sentiment
        - VETO checks
        - TP/SL calculation

        Args:
            symbol: –°–∏–º–≤–æ–ª (–Ω–∞–ø—Ä–∏–º–µ—Ä, "BTCUSDT")

        Returns:
            Dict —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –∞–Ω–∞–ª–∏–∑–∞
        """
        logger.info(f"üîÄ –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ {symbol} –Ω–∞ UnifiedAutoScanner...")
        analysis_start = time.time()

        try:
            # ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º UnifiedAutoScanner —Å –ø–æ–ª–Ω—ã–º MTF –∞–Ω–∞–ª–∏–∑–æ–º!
            signal_data = await self.auto_scanner.scan_symbol(symbol)

            analysis_time = time.time() - analysis_start

            if signal_data:  # ‚Üê Dict –≤–º–µ—Å—Ç–æ int!
                logger.info(
                    f"‚úÖ {symbol}: –°–∏–≥–Ω–∞–ª #{signal_data['signal_id']} —Å–æ–∑–¥–∞–Ω –∑–∞ {analysis_time:.2f}s"
                )
                return {
                    "symbol": symbol,
                    "status": "success",
                    "signal_id": signal_data["signal_id"],
                    "score": signal_data.get("quality_score", 0),
                    "entry_price": signal_data.get("entry_price", 0),
                    "direction": signal_data.get("direction", "LONG"),
                    "analysis_time": analysis_time,
                    "timestamp": datetime.now().isoformat(),
                }

            else:
                logger.info(
                    f"‚ÑπÔ∏è {symbol}: –ü–æ–¥—Ö–æ–¥—è—â–∏—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –∑–∞ {analysis_time:.2f}s"
                )
                return {
                    "symbol": symbol,
                    "status": "success",
                    "signal_id": None,
                    "score": 0,
                    "analysis_time": analysis_time,
                    "timestamp": datetime.now().isoformat(),
                }

        except Exception as e:
            analysis_time = time.time() - analysis_start
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ analyze_symbol_with_batching {symbol}: {e}")
            import traceback

            logger.error(traceback.format_exc())

            return {
                "symbol": symbol,
                "status": "error",
                "error": str(e),
                "score": 0,
                "analysis_time": analysis_time,
                "timestamp": datetime.now().isoformat(),
            }

    def setup_scheduler(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞ –∑–∞–¥–∞—á"""
        try:
            self.scheduler = AsyncIOScheduler(timezone=pytz.UTC)
            self.scheduler.add_job(
                self.update_news,
                "interval",
                minutes=5,
                id="update_news",
                name="–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–µ–π",
                max_instances=1,
            )
            logger.info("‚úÖ –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ scheduler: {e}")
            raise

    async def analyze_symbol_with_validation(self, symbol: str):
        """–ê–Ω–∞–ª–∏–∑ —Å–∏–º–≤–æ–ª–∞ —Å –∫—Ä–æ—Å—Å-–≤–∞–ª–∏–¥–∞—Ü–∏–µ–π –º–µ–∂–¥—É –±–∏—Ä–∂–∞–º–∏"""
        try:
            from analytics.cross_exchange_validator import PriceData

            # 1. –°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö —Å –≤—Å–µ—Ö –±–∏—Ä–∂
            prices = {}

            # Bybit
            if self.bybit_connector:
                try:
                    bybit_price = await self.bybit_connector.get_current_price(symbol)
                    if bybit_price:
                        prices["Bybit"] = PriceData(
                            exchange="Bybit",
                            symbol=symbol,
                            price=float(bybit_price),
                            timestamp=datetime.utcnow(),
                        )
                except Exception as e:
                    logger.debug(f"‚ö†Ô∏è Bybit price unavailable: {e}")

            # Binance
            if self.binance_connector:
                try:
                    binance_orderbook = self.binance_connector.orderbooks.get(
                        symbol.lower()
                    )
                    if binance_orderbook and "last_price" in binance_orderbook:
                        prices["Binance"] = PriceData(
                            exchange="Binance",
                            symbol=symbol,
                            price=float(binance_orderbook["last_price"]),
                            timestamp=datetime.utcnow(),
                            volume_24h=binance_orderbook.get("volume_24h"),
                        )
                except Exception as e:
                    logger.debug(f"‚ö†Ô∏è Binance price unavailable: {e}")

            # OKX
            if self.okx_connector:
                try:
                    okx_symbol = f"{symbol[:3]}-{symbol[3:]}"  # BTCUSDT -> BTC-USDT
                    okx_orderbook = self.okx_connector.orderbooks.get(okx_symbol)
                    if okx_orderbook and "last_price" in okx_orderbook:
                        prices["OKX"] = PriceData(
                            exchange="OKX",
                            symbol=symbol,
                            price=float(okx_orderbook["last_price"]),
                            timestamp=datetime.utcnow(),
                        )
                except Exception as e:
                    logger.debug(f"‚ö†Ô∏è OKX price unavailable: {e}")

            # Coinbase
            if self.coinbase_connector:
                try:
                    cb_symbol = f"{symbol[:3]}-USD"  # BTCUSDT -> BTC-USD
                    cb_orderbook = self.coinbase_connector.orderbooks.get(cb_symbol)
                    if cb_orderbook and "last_price" in cb_orderbook:
                        prices["Coinbase"] = PriceData(
                            exchange="Coinbase",
                            symbol=symbol,
                            price=float(cb_orderbook["last_price"]),
                            timestamp=datetime.utcnow(),
                        )
                except Exception as e:
                    logger.debug(f"‚ö†Ô∏è Coinbase price unavailable: {e}")

            # 2. –í–∞–ª–∏–¥–∞—Ü–∏—è
            if self.cross_validator and len(prices) >= 2:
                validation = await self.cross_validator.validate_price(symbol, prices)

                logger.info(
                    f"üîÑ Cross-validation {symbol}: "
                    f"Status={validation.status.value}, "
                    f"Confidence={validation.confidence:.1f}%, "
                    f"Deviation={validation.price_deviation:.2%}, "
                    f"Exchanges={validation.exchanges_count}"
                )

                # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∞–Ω–æ–º–∞–ª–∏–π
                if validation.anomalies:
                    for anomaly in validation.anomalies:
                        logger.warning(f"‚ö†Ô∏è {symbol} Anomaly: {anomaly.value}")

                        # Arbitrage opportunity
                        if anomaly.value == "arbitrage":
                            details = validation.details
                            exchange_prices = details.get("prices", {})
                            if exchange_prices:
                                cheapest = min(exchange_prices, key=exchange_prices.get)
                                expensive = max(
                                    exchange_prices, key=exchange_prices.get
                                )
                                logger.info(
                                    f"üí∞ ARBITRAGE: {symbol} "
                                    f"Buy on {cheapest} (${exchange_prices[cheapest]:,.2f}) ‚Üí "
                                    f"Sell on {expensive} (${exchange_prices[expensive]:,.2f}) | "
                                    f"Spread: {validation.price_deviation:.2%}"
                                )

                # Telegram alert –µ—Å–ª–∏ –∫—Ä–∏—Ç–∏—á–Ω–æ
                if validation.status.value in ["warning", "invalid"]:
                    if self.telegram_bot:
                        await self.telegram_bot.send_message(
                            f"‚ö†Ô∏è **Cross-Validation Alert**\n\n"
                            f"Symbol: {symbol}\n"
                            f"Status: {validation.status.value.upper()}\n"
                            f"Confidence: {validation.confidence:.1f}%\n"
                            f"Price Deviation: {validation.price_deviation:.2%}\n"
                            f"Exchanges: {validation.exchanges_count}\n"
                            f"Anomalies: {', '.join([a.value for a in validation.anomalies])}"
                        )

                return validation

            else:
                logger.debug(
                    f"‚ö†Ô∏è {symbol}: Insufficient data for validation ({len(prices)} exchanges)"
                )
                return None

        except Exception as e:
            logger.error(f"‚ùå Error in cross-validation for {symbol}: {e}")
            return None

    async def run(self):
        """–ó–∞–ø—É—Å–∫ –≥–ª–∞–≤–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ –±–æ—Ç–∞"""
        try:
            if not self.initialization_complete:
                raise BotRuntimeError("–ë–æ—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

            logger.info(
                f"{Colors.HEADER}üéØ –ó–∞–ø—É—Å–∫ –≥–ª–∞–≤–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ GIO Crypto Bot{Colors.ENDC}"
            )
            self.is_running = True

            self.scheduler.start()
            logger.info("‚úÖ –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∑–∞–ø—É—â–µ–Ω")

            # –ó–∞–ø—É—Å–∫ Telegram Bot
            if self.telegram_handler:
                await self.telegram_handler.initialize()  # ‚Üê –°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
                await self.telegram_handler.start()  # ‚Üê –ü–æ—Ç–æ–º –∑–∞–ø—É—Å–∫
                logger.info("‚úÖ Telegram Bot –∑–∞–ø—É—â–µ–Ω")

            if self.auto_scanner:
                asyncio.create_task(self.auto_scanner.start())
                logger.info("‚úÖ AutoScanner –∑–∞–ø—É—â–µ–Ω")

            if self.auto_roi_tracker:
                asyncio.create_task(self.auto_roi_tracker.start())
                logger.info("‚úÖ AutoROITracker –∑–∞–ø—É—â–µ–Ω")

            # ‚≠ê –ó–∞–ø—É—Å–∫ Binance WebSocket
            if self.binance_connector:
                asyncio.create_task(self.binance_connector.start_websocket())
                logger.info("‚úÖ Binance WebSocket –∑–∞–ø—É—â–µ–Ω")

            # ‚≠ê –ó–∞–ø—É—Å–∫ Binance Orderbook WebSocket
            if self.binance_orderbook_ws:
                asyncio.create_task(self.binance_orderbook_ws.start())
                logger.info("‚úÖ Binance Orderbook WebSocket –∑–∞–ø—É—â–µ–Ω")

            # ‚≠ê –ó–∞–ø—É—Å–∫ OKX WebSocket
            if self.okx_connector:
                asyncio.create_task(self.okx_connector.start_websocket())
                logger.info("‚úÖ OKX WebSocket –∑–∞–ø—É—â–µ–Ω")

            # ‚≠ê –ó–∞–ø—É—Å–∫ Coinbase WebSocket - –î–û–ë–ê–í–ò–¢–¨ –ó–î–ï–°–¨!
            if self.coinbase_connector:
                asyncio.create_task(self.coinbase_connector.start_websocket())
                logger.info("‚úÖ Coinbase WebSocket –∑–∞–ø—É—â–µ–Ω")

            if self.enhanced_alerts:
                asyncio.create_task(self.enhanced_alerts.start_monitoring())
                logger.info("‚úÖ Enhanced Alerts –∑–∞–ø—É—â–µ–Ω")

            # –ó–∞–ø—É—Å–∫ ROI –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º —Ü–µ–Ω
            if self.roi_tracker:
                try:
                    # –ó–∞–ø—É—Å–∫–∞–µ–º ROI Tracker (–≤–∫–ª—é—á–∞–µ—Ç price_updater)
                    await self.roi_tracker.start()
                    logger.info("‚úÖ ROI –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω —Å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º —Ü–µ–Ω")

                    # –ó–∞–ø—É—Å–∫–∞–µ–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
                    await self.roi_tracker.start_monitoring()
                    logger.info("‚úÖ ROI –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞–ø—É—â–µ–Ω")
                except Exception as e:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ ROI –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞: {e}")

            await self.update_news()

            if self.enhanced_sentiment and self.news_connector:
                try:
                    news = await self.news_connector.fetch_unified_news(
                        symbols=["BTC", "ETH"], max_age_hours=24
                    )
                    if news:
                        self.enhanced_sentiment.update_news_cache(news)
                        logger.info("‚úÖ –ö—ç—à –Ω–æ–≤–æ—Å—Ç–µ–π –æ–±–Ω–æ–≤–ª—ë–Ω")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –∫—ç—à –Ω–æ–≤–æ—Å—Ç–µ–π: {e}")

            logger.info(f"{Colors.OKGREEN}üîÑ –ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª –∑–∞–ø—É—â–µ–Ω{Colors.ENDC}")

            while self.is_running:
                await asyncio.sleep(1)

        except Exception as e:
            logger.error(f"{Colors.FAIL}‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}{Colors.ENDC}")
            import traceback

            traceback.print_exc()
            raise BotRuntimeError(f"–û—à–∏–±–∫–∞ –≥–ª–∞–≤–Ω–æ–≥–æ —Ü–∏–∫–ª–∞: {e}")

    async def update_news(self):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–µ–π"""
        try:
            logger.info("üì∞ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–µ–π...")
            news = await self.news_connector.fetch_unified_news(
                symbols=["BTC", "ETH"], max_age_hours=24
            )

            if news:
                self.news_cache = news
                if self.enhanced_sentiment:
                    self.enhanced_sentiment.update_news_cache(news)
                logger.info(f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(news)} –Ω–æ–≤–æ—Å—Ç–µ–π")

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ—Å—Ç–µ–π: {e}")

    async def shutdown(self):
        """–ö–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ—Ç–∞"""
        try:
            logger.info(f"{Colors.WARNING}üõë –ù–∞—á–∞–ª–æ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –±–æ—Ç–∞...{Colors.ENDC}")
            self.is_running = False

            # –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å LogBatcher –ü–ï–†–í–´–ú
            if hasattr(self, "log_batcher"):
                await self.log_batcher.stop()
                logger.info("‚úÖ LogBatcher –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

            if self.auto_scanner:
                await self.auto_scanner.stop()

            if self.auto_roi_tracker:
                await self.auto_roi_tracker.stop()

            # –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å ROI Tracker –ü–ï–†–ï–î –∑–∞–∫—Ä—ã—Ç–∏–µ–º –±–∏—Ä–∂
            if self.roi_tracker:
                logger.info("üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ ROI Tracker...")
                await self.roi_tracker.stop()
                logger.info("‚úÖ ROI Tracker –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

            if self.telegram_bot:
                await self.telegram_bot.stop()

            if self.scheduler and self.scheduler.running:
                self.scheduler.shutdown(wait=False)

            if self.bybit_connector:
                await self.bybit_connector.close()

            # ‚≠ê –ó–∞–∫—Ä—ã—Ç–∏–µ Binance
            if self.binance_connector:
                await self.binance_connector.close()
                logger.info("‚úÖ Binance connector –∑–∞–∫—Ä—ã—Ç")

            # ‚≠ê –ó–∞–∫—Ä—ã—Ç–∏–µ Binance Orderbook WebSocket
            if self.binance_orderbook_ws:
                await self.binance_orderbook_ws.stop()
                logger.info("‚úÖ Binance Orderbook WebSocket –∑–∞–∫—Ä—ã—Ç")

            # ‚≠ê –ó–∞–∫—Ä—ã—Ç–∏–µ OKX
            if self.okx_connector:
                await self.okx_connector.close()
                logger.info("‚úÖ OKX connector –∑–∞–∫—Ä—ã—Ç")

            # ‚≠ê –ó–∞–∫—Ä—ã—Ç–∏–µ Coinbase - –î–û–ë–ê–í–ò–¢–¨ –ó–î–ï–°–¨!
            if self.coinbase_connector:
                await self.coinbase_connector.close()
                logger.info("‚úÖ Coinbase connector –∑–∞–∫—Ä—ã—Ç")

            if self.news_connector:
                await self.news_connector.close()

            if self.orderbook_ws:
                await self.orderbook_ws.stop()

            logger.info(f"{Colors.OKGREEN}‚úÖ –ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω{Colors.ENDC}")

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ: {e}")
