#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Cache Manager - ัะฟัะฐะฒะปะตะฝะธะต in-memory ะบััะตะผ ั TTL
ะฃะผะตะฝััะฐะตั ะบะพะปะธัะตััะฒะพ API ะทะฐะฟัะพัะพะฒ ัะตัะตะท ะบััะธัะพะฒะฐะฝะธะต ะดะฐะฝะฝัั
"""

import time
import asyncio
from typing import Dict, Optional, Any, Tuple
from collections import OrderedDict
from dataclasses import dataclass
from config.settings import logger


@dataclass
class CacheEntry:
    """ะะฐะฟะธัั ะฒ ะบััะต ั metadata"""

    key: str
    value: Any
    timestamp: float
    ttl: float
    hit_count: int = 0

    @property
    def is_expired(self) -> bool:
        """ะัะพะฒะตัะบะฐ ะธััะตัะตะฝะธั TTL"""
        return time.time() - self.timestamp > self.ttl

    @property
    def age(self) -> float:
        """ะะพะทัะฐัั ะทะฐะฟะธัะธ (ัะตะบัะฝะดั)"""
        return time.time() - self.timestamp


class CacheManager:
    """
    In-Memory ะบัั ะผะตะฝะตะดะถะตั ั TTL

    Features:
    - LRU (Least Recently Used) eviction
    - TTL (Time To Live) ะดะปั ะฐะฒัะพะผะฐัะธัะตัะบะพะน ะพัะธััะบะธ
    - Hit/Miss ััะฐัะธััะธะบะฐ
    - Namespace support ะดะปั ัะฐะทะดะตะปะตะฝะธั ะดะฐะฝะฝัั
    """

    def __init__(self, max_size: int = 1000, default_ttl: float = 60.0):
        """
        Args:
            max_size: ะะฐะบัะธะผะฐะปัะฝะพะต ะบะพะปะธัะตััะฒะพ ะทะฐะฟะธัะตะน
            default_ttl: TTL ะฟะพ ัะผะพะปัะฐะฝะธั (ัะตะบัะฝะดั)
        """
        self.max_size = max_size
        self.default_ttl = default_ttl

        # OrderedDict ะดะปั LRU
        self.cache: OrderedDict[str, CacheEntry] = OrderedDict()

        # ะกัะฐัะธััะธะบะฐ
        self.stats = {
            "hits": 0,
            "misses": 0,
            "evictions": 0,
            "expirations": 0,
            "total_requests": 0,
        }

        # Lock ะดะปั thread-safety
        self.lock = asyncio.Lock()

        logger.info(
            f"โ CacheManager ะธะฝะธัะธะฐะปะธะทะธัะพะฒะฐะฝ: "
            f"max_size={max_size}, default_ttl={default_ttl}s"
        )

    async def get(self, key: str, namespace: str = "default") -> Optional[Any]:
        """
        ะะพะปััะธัั ะทะฝะฐัะตะฝะธะต ะธะท ะบััะฐ

        Args:
            key: ะะปัั
            namespace: ะัะพัััะฐะฝััะฒะพ ะธะผัะฝ

        Returns:
            ะะฝะฐัะตะฝะธะต ะธะปะธ None ะตัะปะธ ะฝะต ะฝะฐะนะดะตะฝะพ/ะธััะตะบะปะพ
        """
        async with self.lock:
            self.stats["total_requests"] += 1
            full_key = f"{namespace}:{key}"

            # ะัะพะฒะตััะตะผ ะฝะฐะปะธัะธะต ะฒ ะบััะต
            if full_key not in self.cache:
                self.stats["misses"] += 1
                logger.debug(f"โ Cache MISS: {full_key}")
                return None

            entry = self.cache[full_key]

            # ะัะพะฒะตััะตะผ TTL
            if entry.is_expired:
                self.stats["misses"] += 1
                self.stats["expirations"] += 1
                del self.cache[full_key]
                logger.debug(f"โฐ Cache EXPIRED: {full_key} (age: {entry.age:.1f}s)")
                return None

            # Hit! ะะฑะฝะพะฒะปัะตะผ ััะฐัะธััะธะบั ะธ LRU order
            self.stats["hits"] += 1
            entry.hit_count += 1
            self.cache.move_to_end(full_key)

            logger.debug(
                f"โ Cache HIT: {full_key} "
                f"(age: {entry.age:.1f}s, hits: {entry.hit_count})"
            )

            return entry.value

    async def set(
        self,
        key: str,
        value: Any,
        ttl: Optional[float] = None,
        namespace: str = "default",
    ) -> None:
        """
        ะกะพััะฐะฝะธัั ะทะฝะฐัะตะฝะธะต ะฒ ะบัั

        Args:
            key: ะะปัั
            value: ะะฝะฐัะตะฝะธะต
            ttl: TTL (ัะตะบัะฝะดั), ะตัะปะธ None - ะธัะฟะพะปัะทัะตั default_ttl
            namespace: ะัะพัััะฐะฝััะฒะพ ะธะผัะฝ
        """
        async with self.lock:
            full_key = f"{namespace}:{key}"
            ttl = ttl if ttl is not None else self.default_ttl

            # ะกะพะทะดะฐัะผ ะทะฐะฟะธัั
            entry = CacheEntry(
                key=full_key, value=value, timestamp=time.time(), ttl=ttl
            )

            # ะัะปะธ ะดะพััะธะณะปะธ ะปะธะผะธัะฐ - ัะดะฐะปัะตะผ ัะฐะผัั ััะฐััั ะทะฐะฟะธัั (LRU)
            if len(self.cache) >= self.max_size and full_key not in self.cache:
                oldest_key = next(iter(self.cache))
                del self.cache[oldest_key]
                self.stats["evictions"] += 1
                logger.debug(f"๐๏ธ Cache EVICTED (LRU): {oldest_key}")

            # ะะพะฑะฐะฒะปัะตะผ/ะพะฑะฝะพะฒะปัะตะผ ะทะฐะฟะธัั
            self.cache[full_key] = entry
            self.cache.move_to_end(full_key)

            logger.debug(f"๐พ Cache SET: {full_key} (ttl: {ttl}s)")

    async def delete(self, key: str, namespace: str = "default") -> bool:
        """
        ะฃะดะฐะปะธัั ะทะฝะฐัะตะฝะธะต ะธะท ะบััะฐ

        Args:
            key: ะะปัั
            namespace: ะัะพัััะฐะฝััะฒะพ ะธะผัะฝ

        Returns:
            True ะตัะปะธ ัะดะฐะปะตะฝะพ, False ะตัะปะธ ะฝะต ะฝะฐะนะดะตะฝะพ
        """
        async with self.lock:
            full_key = f"{namespace}:{key}"
            if full_key in self.cache:
                del self.cache[full_key]
                logger.debug(f"๐๏ธ Cache DELETE: {full_key}")
                return True
            return False

    async def clear(self, namespace: Optional[str] = None) -> int:
        """
        ะัะธััะธัั ะบัั

        Args:
            namespace: ะัะปะธ ัะบะฐะทะฐะฝะพ - ะพัะธัะฐะตั ัะพะปัะบะพ ััะพั namespace

        Returns:
            ะะพะปะธัะตััะฒะพ ัะดะฐะปัะฝะฝัั ะทะฐะฟะธัะตะน
        """
        async with self.lock:
            if namespace is None:
                # ะัะธัะฐะตะผ ะฒะตัั ะบัั
                count = len(self.cache)
                self.cache.clear()
                logger.info(f"๐๏ธ Cache CLEARED: {count} ะทะฐะฟะธัะตะน")
                return count
            else:
                # ะัะธัะฐะตะผ ัะพะปัะบะพ ัะบะฐะทะฐะฝะฝัะน namespace
                prefix = f"{namespace}:"
                keys_to_delete = [k for k in self.cache.keys() if k.startswith(prefix)]
                for key in keys_to_delete:
                    del self.cache[key]
                logger.info(
                    f"๐๏ธ Cache CLEARED namespace '{namespace}': "
                    f"{len(keys_to_delete)} ะทะฐะฟะธัะตะน"
                )
                return len(keys_to_delete)

    async def cleanup_expired(self) -> int:
        """
        ะฃะดะฐะปะธัั ะฒัะต ะธัััะบัะธะต ะทะฐะฟะธัะธ

        Returns:
            ะะพะปะธัะตััะฒะพ ัะดะฐะปัะฝะฝัั ะทะฐะฟะธัะตะน
        """
        async with self.lock:
            expired_keys = [
                key for key, entry in self.cache.items() if entry.is_expired
            ]

            for key in expired_keys:
                del self.cache[key]
                self.stats["expirations"] += 1

            if expired_keys:
                logger.debug(f"๐๏ธ Cache cleanup: {len(expired_keys)} ะธัััะบัะธั ะทะฐะฟะธัะตะน")

            return len(expired_keys)

    def get_stats(self) -> Dict[str, Any]:
        """
        ะะพะปััะธัั ััะฐัะธััะธะบั ะบััะฐ

        Returns:
            Dict ัะพ ััะฐัะธััะธะบะพะน
        """
        total = self.stats["total_requests"]
        hits = self.stats["hits"]
        misses = self.stats["misses"]

        hit_rate = (hits / total * 100) if total > 0 else 0.0
        miss_rate = (misses / total * 100) if total > 0 else 0.0

        return {
            **self.stats,
            "hit_rate": hit_rate,
            "miss_rate": miss_rate,
            "cache_size": len(self.cache),
            "max_size": self.max_size,
            "utilization": (len(self.cache) / self.max_size * 100),
        }

    def get_detailed_stats(self) -> Dict[str, Any]:
        """
        ะะพะปััะธัั ะดะตัะฐะปัะฝัั ััะฐัะธััะธะบั

        Returns:
            Dict ั ะฟะพะดัะพะฑะฝะพะน ััะฐัะธััะธะบะพะน
        """
        stats = self.get_stats()

        # ะขะพะฟ ะทะฐะฟะธัะตะน ะฟะพ ะบะพะปะธัะตััะฒั hits
        top_entries = sorted(
            self.cache.values(), key=lambda e: e.hit_count, reverse=True
        )[:10]

        stats["top_entries"] = [
            {
                "key": entry.key,
                "hits": entry.hit_count,
                "age": entry.age,
                "ttl": entry.ttl,
            }
            for entry in top_entries
        ]

        return stats

    def get_statistics(self) -> Dict[str, Any]:
        """
        Alias ะดะปั get_stats() - ะดะปั ัะพะฒะผะตััะธะผะพััะธ

        Returns:
            Dict ัะพ ััะฐัะธััะธะบะพะน (ะฒะบะปััะฐั ัะฐะทะผะตั ะฒ MB)
        """
        stats = self.get_stats()

        # ะะพะฑะฐะฒะปัะตะผ ัะฐะทะผะตั ะฒ MB (ะฟัะธะผะตัะฝะฐั ะพัะตะฝะบะฐ)
        stats["total_size_mb"] = stats["cache_size"] * 0.001  # ะัะธะผะตัะฝะพ 1KB ะฝะฐ ะทะฐะฟะธัั
        stats["total_items"] = stats["cache_size"]

        return stats

    async def auto_cleanup_loop(self, interval: float = 60.0):
        """
        ะะฒัะพะผะฐัะธัะตัะบะฐั ะพัะธััะบะฐ ะธัััะบัะธั ะทะฐะฟะธัะตะน

        Args:
            interval: ะะฝัะตัะฒะฐะป ะฟัะพะฒะตัะบะธ (ัะตะบัะฝะดั)
        """
        logger.info(f"๐ ะะฐะฟััะตะฝะฐ ะฐะฒัะพะผะฐัะธัะตัะบะฐั ะพัะธััะบะฐ ะบััะฐ (ะบะฐะถะดัะต {interval}s)")

        while True:
            try:
                await asyncio.sleep(interval)
                expired_count = await self.cleanup_expired()

                if expired_count > 0:
                    logger.debug(
                        f"๐๏ธ ะะฒัะพะพัะธััะบะฐ: ัะดะฐะปะตะฝะพ {expired_count} ะธัััะบัะธั ะทะฐะฟะธัะตะน"
                    )

            except asyncio.CancelledError:
                logger.info("๐ ะััะฐะฝะพะฒะปะตะฝะฐ ะฐะฒัะพะผะฐัะธัะตัะบะฐั ะพัะธััะบะฐ ะบััะฐ")
                break
            except Exception as e:
                logger.error(f"โ ะัะธะฑะบะฐ ะฒ auto_cleanup_loop: {e}")


# ะะปะพะฑะฐะปัะฝัะน ัะบะทะตะผะฟะปัั Cache Manager
_global_cache_manager: Optional[CacheManager] = None


def get_cache_manager() -> CacheManager:
    """ะะพะปััะธัั ะณะปะพะฑะฐะปัะฝัะน Cache Manager (Singleton)"""
    global _global_cache_manager
    if _global_cache_manager is None:
        _global_cache_manager = CacheManager(
            max_size=1000, default_ttl=10.0  # 10 ัะตะบัะฝะด ะดะปั ticker data
        )
    return _global_cache_manager


# ะญะบัะฟะพัั
__all__ = ["CacheManager", "CacheEntry", "get_cache_manager"]
